#!/usr/bin/env ruby


$current_cell = 0

[:S,:K,:I,:zero,:succ,:dbl,:get,:put,:inc,
:dec,:attack,:help,:copy,:revive,:zombie
].each{|op|eval"def #{op.to_s.downcase}(c=$current_cell); pa :#{op},c; end;def #{op.to_s.downcase}!(c=$current_cell); op :#{op},c; end;"}

def op(op, c=$current_cell)
  return op.each {|op2| op op2, c} if op.is_a? Array
  puts 1
  puts op.to_s
  puts c
end

def pa(op, c=$current_cell)
  return op.each {|op2| p op2, c} if op.is_a? Array
  puts 2
  puts c
  puts op.to_s
end

# Applies a _p function
# returns _op(_p0(_p1(p2(...))))
def pp(_op, *_p)
  k!
  s!
  send _op
  if _p.length > 1
    pp _p.shift, *_p
  else
    send _p.first unless _p.nil?
  end
end


def app(*ops)
  k! ; s!
  case ops.length
  when 1
    send ops.first
  when 2
    s!
    send ops.shift
  when 3
  when 4
  end
end

def slot(c=$current_cell, &block)
  old_cell, $current_cell = $current_cell, c
  yield if block_given?
  $current_cell = old_cell
end


def recurse_attack
    slot 0 do
        zero; succ!;
        12.times { dbl! }
    end

    slot 1 do
        attack
          zero
          pp :succ, :zero
          pp :get, :zero
    end
end

# recurse dec()
# save formula in slot 0
slot 0 do
    slot(1) { s; dec; i }
    slot(2) { s; pp :k, :get; pp :k, :zero }
    s
      pp :get, :succ, :succ, :zero
      pp :get, :succ, :zero
    slot(1) { put! }
    slot(2) { put! }
end

# save index in slot 1
slot 1 do
    zero; succ!
end

2.upto(122) do |j|
    # update index
    slot(1) { succ! }

    # copy formula into slot
    slot(j) { get; zero }
    1.upto(91) do |i|
        slot(j) { pp :get, :succ, :zero; get; zero }
    end
end

# padding, so that we don't get pipe error
504.times { i! }
